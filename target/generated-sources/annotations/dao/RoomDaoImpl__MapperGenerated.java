package dao;

import com.datastax.oss.driver.api.core.cql.BoundStatement;
import com.datastax.oss.driver.api.core.cql.BoundStatementBuilder;
import com.datastax.oss.driver.api.core.cql.PreparedStatement;
import com.datastax.oss.driver.api.core.cql.ResultSet;
import com.datastax.oss.driver.api.core.cql.Row;
import com.datastax.oss.driver.api.core.cql.SimpleStatement;
import com.datastax.oss.driver.api.mapper.MapperContext;
import com.datastax.oss.driver.api.mapper.entity.saving.NullSavingStrategy;
import com.datastax.oss.driver.internal.core.util.concurrent.BlockingOperation;
import com.datastax.oss.driver.internal.core.util.concurrent.CompletableFutures;
import com.datastax.oss.driver.internal.mapper.DaoBase;
import com.datastax.oss.driver.internal.querybuilder.update.DefaultUpdate;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.lang.Throwable;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import model.Room;
import model.RoomHelper__MapperGenerated;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Generated by the DataStax driver mapper, do not edit directly.
 */
@SuppressWarnings("all")
public class RoomDaoImpl__MapperGenerated extends DaoBase implements RoomDao {
  private static final Logger LOG = LoggerFactory.getLogger(RoomDaoImpl__MapperGenerated.class);

  private final RoomHelper__MapperGenerated roomHelper;

  private final PreparedStatement createRoomStatement;

  private final PreparedStatement updateRoomStatement;

  private final PreparedStatement deleteRoomStatement;

  private RoomDaoImpl__MapperGenerated(MapperContext context,
      RoomHelper__MapperGenerated roomHelper, PreparedStatement createRoomStatement,
      PreparedStatement updateRoomStatement, PreparedStatement deleteRoomStatement) {
    super(context);
    this.roomHelper = roomHelper;
    this.createRoomStatement = createRoomStatement;
    this.updateRoomStatement = updateRoomStatement;
    this.deleteRoomStatement = deleteRoomStatement;
  }

  @Override
  public void createRoom(Room room) {
    BoundStatementBuilder boundStatementBuilder = createRoomStatement.boundStatementBuilder();
    roomHelper.set(room, boundStatementBuilder, NullSavingStrategy.DO_NOT_SET, false);
    BoundStatement boundStatement = boundStatementBuilder.build();
    execute(boundStatement);
  }

  @Override
  public Room readRoom(ResultSet resultSet) {
    Row row = resultSet.one();
    return (row == null) ? null : roomHelper.get(row, false);
  }

  @Override
  public void updateRoom(Room room) {
    BoundStatementBuilder boundStatementBuilder = updateRoomStatement.boundStatementBuilder();
    roomHelper.set(room, boundStatementBuilder, NullSavingStrategy.DO_NOT_SET, false);
    BoundStatement boundStatement = boundStatementBuilder.build();
    execute(boundStatement);
  }

  @Override
  public void deleteRoom(Room room) {
    BoundStatementBuilder boundStatementBuilder = deleteRoomStatement.boundStatementBuilder();
    boundStatementBuilder = boundStatementBuilder.set("room_id", room.getRoom_id(), String.class);
    BoundStatement boundStatement = boundStatementBuilder.build();
    execute(boundStatement);
  }

  public static CompletableFuture<RoomDao> initAsync(MapperContext context) {
    LOG.debug("[{}] Initializing new instance for keyspace = {} and table = {}",
        context.getSession().getName(),
        context.getKeyspaceId(),
        context.getTableId());
    throwIfProtocolVersionV3(context);
    try {
      // Initialize all entity helpers
      RoomHelper__MapperGenerated roomHelper = new RoomHelper__MapperGenerated(context);
      if ((Boolean)context.getCustomState().get("datastax.mapper.schemaValidationEnabled")) {
        roomHelper.validateEntityFields();
      }
      List<CompletionStage<PreparedStatement>> prepareStages = new ArrayList<>();
      // Prepare the statement for `createRoom(model.Room)`:
      SimpleStatement createRoomStatement_simple = roomHelper.insert().build();
      LOG.debug("[{}] Preparing query `{}` for method createRoom(model.Room)",
          context.getSession().getName(),
          createRoomStatement_simple.getQuery());
      CompletionStage<PreparedStatement> createRoomStatement = prepare(createRoomStatement_simple, context);
      prepareStages.add(createRoomStatement);
      // Prepare the statement for `updateRoom(model.Room)`:
      SimpleStatement updateRoomStatement_simple = SimpleStatement.newInstance(((DefaultUpdate)roomHelper.updateByPrimaryKey()).asCql());
      LOG.debug("[{}] Preparing query `{}` for method updateRoom(model.Room)",
          context.getSession().getName(),
          updateRoomStatement_simple.getQuery());
      CompletionStage<PreparedStatement> updateRoomStatement = prepare(updateRoomStatement_simple, context);
      prepareStages.add(updateRoomStatement);
      // Prepare the statement for `deleteRoom(model.Room)`:
      SimpleStatement deleteRoomStatement_simple = roomHelper.deleteByPrimaryKeyParts(1).build();
      LOG.debug("[{}] Preparing query `{}` for method deleteRoom(model.Room)",
          context.getSession().getName(),
          deleteRoomStatement_simple.getQuery());
      CompletionStage<PreparedStatement> deleteRoomStatement = prepare(deleteRoomStatement_simple, context);
      prepareStages.add(deleteRoomStatement);
      // Initialize all method invokers
      // Build the DAO when all statements are prepared
      return CompletableFutures.allSuccessful(prepareStages)
          .thenApply(v -> (RoomDao) new RoomDaoImpl__MapperGenerated(context,
              roomHelper,
              CompletableFutures.getCompleted(createRoomStatement),
              CompletableFutures.getCompleted(updateRoomStatement),
              CompletableFutures.getCompleted(deleteRoomStatement)))
          .toCompletableFuture();
    } catch (Throwable t) {
      return CompletableFutures.failedFuture(t);
    }
  }

  public static RoomDao init(MapperContext context) {
    BlockingOperation.checkNotDriverThread();
    return CompletableFutures.getUninterruptibly(initAsync(context));
  }
}
