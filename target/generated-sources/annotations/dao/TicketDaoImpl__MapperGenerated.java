package dao;

import com.datastax.oss.driver.api.core.cql.BoundStatement;
import com.datastax.oss.driver.api.core.cql.BoundStatementBuilder;
import com.datastax.oss.driver.api.core.cql.PreparedStatement;
import com.datastax.oss.driver.api.core.cql.ResultSet;
import com.datastax.oss.driver.api.core.cql.Row;
import com.datastax.oss.driver.api.core.cql.SimpleStatement;
import com.datastax.oss.driver.api.mapper.MapperContext;
import com.datastax.oss.driver.api.mapper.entity.saving.NullSavingStrategy;
import com.datastax.oss.driver.internal.core.util.concurrent.BlockingOperation;
import com.datastax.oss.driver.internal.core.util.concurrent.CompletableFutures;
import com.datastax.oss.driver.internal.mapper.DaoBase;
import com.datastax.oss.driver.internal.querybuilder.update.DefaultUpdate;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.lang.Throwable;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import model.Ticket;
import model.TicketHelper__MapperGenerated;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Generated by the DataStax driver mapper, do not edit directly.
 */
@SuppressWarnings("all")
public class TicketDaoImpl__MapperGenerated extends DaoBase implements TicketDao {
  private static final Logger LOG = LoggerFactory.getLogger(TicketDaoImpl__MapperGenerated.class);

  private final TicketHelper__MapperGenerated ticketHelper;

  private final PreparedStatement createTicketStatement;

  private final PreparedStatement updateTicketStatement;

  private final PreparedStatement deleteTicketStatement;

  private TicketDaoImpl__MapperGenerated(MapperContext context,
      TicketHelper__MapperGenerated ticketHelper, PreparedStatement createTicketStatement,
      PreparedStatement updateTicketStatement, PreparedStatement deleteTicketStatement) {
    super(context);
    this.ticketHelper = ticketHelper;
    this.createTicketStatement = createTicketStatement;
    this.updateTicketStatement = updateTicketStatement;
    this.deleteTicketStatement = deleteTicketStatement;
  }

  @Override
  public void createTicket(Ticket ticket) {
    BoundStatementBuilder boundStatementBuilder = createTicketStatement.boundStatementBuilder();
    ticketHelper.set(ticket, boundStatementBuilder, NullSavingStrategy.DO_NOT_SET, false);
    BoundStatement boundStatement = boundStatementBuilder.build();
    execute(boundStatement);
  }

  @Override
  public Ticket readTicket(ResultSet resultSet) {
    Row row = resultSet.one();
    return (row == null) ? null : ticketHelper.get(row, false);
  }

  @Override
  public void updateTicket(Ticket ticket) {
    BoundStatementBuilder boundStatementBuilder = updateTicketStatement.boundStatementBuilder();
    ticketHelper.set(ticket, boundStatementBuilder, NullSavingStrategy.DO_NOT_SET, false);
    BoundStatement boundStatement = boundStatementBuilder.build();
    execute(boundStatement);
  }

  @Override
  public void deleteTicket(Ticket ticket) {
    BoundStatementBuilder boundStatementBuilder = deleteTicketStatement.boundStatementBuilder();
    boundStatementBuilder = boundStatementBuilder.set("ticket_id", ticket.getTicket_id(), String.class);
    BoundStatement boundStatement = boundStatementBuilder.build();
    execute(boundStatement);
  }

  public static CompletableFuture<TicketDao> initAsync(MapperContext context) {
    LOG.debug("[{}] Initializing new instance for keyspace = {} and table = {}",
        context.getSession().getName(),
        context.getKeyspaceId(),
        context.getTableId());
    throwIfProtocolVersionV3(context);
    try {
      // Initialize all entity helpers
      TicketHelper__MapperGenerated ticketHelper = new TicketHelper__MapperGenerated(context);
      if ((Boolean)context.getCustomState().get("datastax.mapper.schemaValidationEnabled")) {
        ticketHelper.validateEntityFields();
      }
      List<CompletionStage<PreparedStatement>> prepareStages = new ArrayList<>();
      // Prepare the statement for `createTicket(model.Ticket)`:
      SimpleStatement createTicketStatement_simple = ticketHelper.insert().build();
      LOG.debug("[{}] Preparing query `{}` for method createTicket(model.Ticket)",
          context.getSession().getName(),
          createTicketStatement_simple.getQuery());
      CompletionStage<PreparedStatement> createTicketStatement = prepare(createTicketStatement_simple, context);
      prepareStages.add(createTicketStatement);
      // Prepare the statement for `updateTicket(model.Ticket)`:
      SimpleStatement updateTicketStatement_simple = SimpleStatement.newInstance(((DefaultUpdate)ticketHelper.updateByPrimaryKey()).asCql());
      LOG.debug("[{}] Preparing query `{}` for method updateTicket(model.Ticket)",
          context.getSession().getName(),
          updateTicketStatement_simple.getQuery());
      CompletionStage<PreparedStatement> updateTicketStatement = prepare(updateTicketStatement_simple, context);
      prepareStages.add(updateTicketStatement);
      // Prepare the statement for `deleteTicket(model.Ticket)`:
      SimpleStatement deleteTicketStatement_simple = ticketHelper.deleteByPrimaryKeyParts(1).build();
      LOG.debug("[{}] Preparing query `{}` for method deleteTicket(model.Ticket)",
          context.getSession().getName(),
          deleteTicketStatement_simple.getQuery());
      CompletionStage<PreparedStatement> deleteTicketStatement = prepare(deleteTicketStatement_simple, context);
      prepareStages.add(deleteTicketStatement);
      // Initialize all method invokers
      // Build the DAO when all statements are prepared
      return CompletableFutures.allSuccessful(prepareStages)
          .thenApply(v -> (TicketDao) new TicketDaoImpl__MapperGenerated(context,
              ticketHelper,
              CompletableFutures.getCompleted(createTicketStatement),
              CompletableFutures.getCompleted(updateTicketStatement),
              CompletableFutures.getCompleted(deleteTicketStatement)))
          .toCompletableFuture();
    } catch (Throwable t) {
      return CompletableFutures.failedFuture(t);
    }
  }

  public static TicketDao init(MapperContext context) {
    BlockingOperation.checkNotDriverThread();
    return CompletableFutures.getUninterruptibly(initAsync(context));
  }
}
